# Solver 架构概述

本章以"总-分-总"结构说明 Solver 的模块划分、数据流与扩展方向。

## 本节目的（总）

- 说明核心模块与职责边界
- 建立代码与文档的映射关系
- 提供架构扩展指南

## 模块划分（分）

### 核心模块

#### `solver/core/`：算法与公共抽象

**职责**：
- 实现 CFR、CFR+、MCCFR 等核心算法
- 定义信息集合（InfoSet）的抽象接口
- 提供策略更新与后悔值计算的基础功能

**关键文件**：
- `cfr.py`：Vanilla CFR 算法实现
- `infoset.py`：信息集合数据结构（待实现）
- `strategy.py`：策略存储与更新（待实现）

**设计原则**：
- 算法与游戏解耦，通过接口交互
- 支持多种算法变体，便于对比实验
- 提供清晰的抽象，便于扩展到复杂博弈

#### `solver/game/`：博弈定义与规则

**职责**：
- 定义游戏状态、合法行动、收益计算
- 实现信息集合的编码方法
- 提供游戏初始状态与终局判断

**关键文件**：
- `kuhn.py`：Kuhn Poker 实现（已完成）
- `leduc.py`：Leduc Poker 实现（待实现）
- `holdem.py`：德州扑克抽象实现（待实现）
- `types.py`：游戏状态与接口定义（待实现）

**设计原则**：
- 每个游戏独立实现，便于验证
- 统一的接口规范，便于算法复用
- 支持状态序列化，便于调试与可视化

#### `solver/tree/`：状态树与行动树

**职责**：
- 构建与遍历博弈树
- 管理状态节点与信息集合的映射
- 提供树的可视化与导出功能

**关键文件**：
- `tree_builder.py`：博弈树构建器（待实现）
- `tree_traversal.py`：树遍历算法（待实现）
- `visualization.py`：树可视化工具（待实现）

**设计原则**：
- 支持按需构建，避免内存爆炸
- 提供高效的查找与遍历接口
- 支持大规模博弈的抽象表示

#### `solver/training/`：训练流程与配置

**职责**：
- 管理训练循环与检查点
- 配置算法参数与训练策略
- 记录训练过程与中间结果

**关键文件**：
- `train_kuhn.py`：Kuhn Poker 训练脚本（已完成）
- `train_leduc.py`：Leduc Poker 训练脚本（待实现）
- `config.py`：训练配置管理（待实现）
- `checkpoint.py`：检查点保存与加载（待实现）

**设计原则**：
- 训练脚本独立，便于单独运行
- 配置与代码分离，便于实验管理
- 支持断点续训，提高训练效率

#### `solver/eval/`：评估与对比

**职责**：
- 计算策略质量指标（收敛性、与理论解差异）
- 对比不同算法的性能
- 生成评估报告与可视化

**关键文件**：
- `report.py`：评估报告生成（已完成）
- `metrics.py`：指标计算（待实现）
- `comparison.py`：算法对比工具（待实现）

**设计原则**：
- 指标计算独立，便于复用
- 报告格式统一，便于对比
- 支持多种可视化方式

#### `solver/cli/`：命令行入口

**职责**：
- 提供命令行接口，便于快速训练与测试
- 解析参数与配置
- 调用训练与评估模块

**关键文件**：
- `run_kuhn.py`：Kuhn Poker 训练入口（已完成）
- `run_leduc.py`：Leduc Poker 训练入口（待实现）
- `analyze.py`：策略分析工具（待实现）

**设计原则**：
- 命令行接口简洁，参数清晰
- 支持批量训练与自动化实验
- 提供友好的输出格式

## 数据流（分）

### 训练流程

```
1. 初始化
   ├─ 创建游戏实例（Game）
   ├─ 创建算法实例（CFR）
   └─ 初始化信息集合字典（InfoSets）

2. 训练循环（迭代 N 轮）
   ├─ 遍历所有可能的发牌组合
   ├─ 对每个组合执行 CFR 遍历
   │  ├─ 计算当前信息集合的策略
   │  ├─ 递归遍历子节点
   │  ├─ 计算反事实收益
   │  └─ 更新后悔值
   └─ 记录策略变化（可选）

3. 输出结果
   ├─ 计算平均策略
   ├─ 生成策略文件（JSON）
   ├─ 生成评估报告
   └─ 可视化策略树（可选）
```

### 信息集合编码

**Kuhn Poker 示例**：
- 信息集合键：`{手牌}{历史}`
- 例如：`"1p"` 表示玩家拿到牌 1（J），历史为 "p"（过牌）
- 例如：`"2b"` 表示玩家拿到牌 2（Q），历史为 "b"（下注）

**设计原则**：
- 编码唯一且可逆
- 相同信息集合使用相同键
- 支持快速查找与更新

### 策略存储格式

**JSON 格式示例**：
```json
{
  "1p": {"p": 0.67, "b": 0.33},
  "2p": {"p": 0.67, "b": 0.33},
  "3p": {"p": 0.0, "b": 1.0},
  "1b": {"f": 1.0, "c": 0.0},
  "2b": {"f": 0.67, "c": 0.33},
  "3b": {"f": 0.0, "c": 1.0}
}
```

**设计原则**：
- 格式简洁，便于解析
- 包含完整信息，便于分析
- 支持版本控制，便于对比

## 扩展方向（分）

### 短期扩展（1-3 个月）

1. **Leduc Poker 实现**
   - 实现 2 轮下注的简化德州
   - 验证 CFR 在多街博弈中的表现
   - 对比单街与多街的策略差异

2. **算法变体**
   - 实现 CFR+（线性后悔值更新）
   - 实现 MCCFR（蒙特卡洛采样）
   - 对比不同算法的收敛速度

3. **性能优化**
   - 向量化计算（NumPy）
   - 并行训练（多线程/多进程）
   - 内存优化（状态压缩）

### 中期扩展（3-6 个月）

1. **德州抽象**
   - 实现 3 张牌抽象（翻牌前）
   - 实现单街简化（翻牌后）
   - 支持自定义抽象粒度

2. **策略分析工具**
   - 策略可视化（热力图、决策树）
   - 范围演化追踪
   - 频率分析工具

3. **训练优化**
   - 自适应学习率
   - 提前停止机制
   - 检查点管理

### 长期扩展（6-12 个月）

1. **完整德州实现**
   - 翻牌、转牌、河牌完整流程
   - 支持多玩家（2-9 人）
   - 支持不同盲注结构

2. **大规模训练**
   - 分布式训练（多机）
   - GPU 加速（CUDA）
   - 增量训练与在线学习

3. **实战集成**
   - 实时策略查询
   - 范围建议工具
   - 复盘分析系统

## 设计原则总结（总）

### 模块化

- 每个模块职责清晰，边界明确
- 模块间通过接口交互，降低耦合
- 便于独立开发、测试与维护

### 可扩展性

- 支持新游戏、新算法的快速接入
- 提供清晰的扩展点与接口规范
- 保持向后兼容，避免破坏性变更

### 可验证性

- 每个模块提供单元测试
- 支持与理论解的对比验证
- 提供详细的日志与调试工具

### 性能与效率

- 算法实现高效，避免不必要的计算
- 支持并行化与向量化优化
- 提供性能分析与优化工具

## 总结（总）

Solver 架构遵循"抽象清晰、可扩展、可验证"的原则，通过模块化设计、统一接口与清晰的扩展方向，支持从简单博弈逐步扩展到复杂德州扑克。架构设计兼顾理论正确性、实现效率与工程实践，为构建完整的 GTO Solver 提供坚实基础。
